/*
    题目分析：计算从1到n所有的数字中，1出现了多少次。

    解题思路：如果遍历1到n的每个数字，时间复杂度是O(nlogn)。以 n = 621345为例：

    1. 发现 n = 621345的返回值和 n = 21345 的返回值是有联系的。同时21346-621345这段，是长度为600000的区间。
    2. 研究 21346-621345 中 1的个数，会发现它其实等价于 0 - 599999 区间中 1 的个数。
    3. 0-599999 其实是由6个 0 - 99999 这样的相似区间组成的。100000 - 199999 比较特别，需要额外加上100000个 1
    4. 分别观察0-9，0-99，0-999，0-9999等区间的1的个数可以发现规律：1，20，300，4000……
        比如0-99共含有20个1：10、11、……19 考虑十位上的1.还有1，11，21……91考虑个位数上的1
        变成0-999时，这20个数字每一个后面都可以添加0-9，所以是200个1，这些是不考虑个位数为1的情况。
        考虑个位数上的1，显然没10个数有一个，所以共有 1000 / 10 = 100个。
    5. 所以说，0- 10^i -1 这个区间内的 1 的个数是有规律的，0 - 599999 区间中 1 的个数也就好算了。
    6. 如果是计算21346 到 121345，需要考虑100000 - 121346这一段的特殊情况，这里面的每个数最高位都有1.
    7. 如果是计算21346 到 101345，就不要考虑这些 1。这不是当前这一步计算的范畴。

    算法的核心是计算那一段整数区间内 1 的个数，也就是number每次迭代的增量。然后只要递归处理即可。这个增量可以表达为：

     firstBit * (bits - 1) * pow(10, bits - 2) + (firstBit > 1 ? pow(10, bits - 1) : (firstBit == 1 ? n + 1 : 0));

     其中，firstBit * (bits - 1) * pow(10, bits - 2) 是指有 firstBit 段 0 - 9……9，每一段的1的个数根据规律，
     是(bits - 1) * pow(10, bits - 2)，比如0-99999 就含有 (6-1) * 10^4 = 50000个 1.

     如果首位大于1，还需要考虑到 10……0 - 19……9这一段额外的最高位的1.也就是 pow(10, bits - 1) 个
     如果首位等于1，需要考虑的是 10……0 - 1xxxx这一段额外的最高位的1.也就是 n + 1 个(这时n已经去掉了最高位)
     如果首位等于0，说明这是上次遗留下来的，比如101 的想下一次是 1，这时候相当于01，所以什么都不做，让 bit 减 1
*/

/// 计算n是几位数
int getBitsOfNumber(int n) {
    int bits = 0;
    while (n) {
        ++bits;
        n /= 10;
    }
    return bits;
}

int countDigitOne(int n) {
    int number = 0;
    for (int bits = getBitsOfNumber(n); n > 0; --bits) {// bits表示n是几位数，比如621345是6位数
        int powerOfTen = pow(10, bits - 1); // 这是10的若干次方，数量级不大于n，如n=621345，这个数等于100000
        int firstBit = n / powerOfTen;  // 第一位数字，比如621345的第一位是6
        n -= firstBit * powerOfTen;   // 去掉了首位的n，比如621345变成21345
        number += firstBit * (bits - 1) * pow(10, bits - 2) + (firstBit > 1 ? pow(10, bits - 1) : (firstBit == 1 ? n + 1 : 0));
    }
    return number;
}